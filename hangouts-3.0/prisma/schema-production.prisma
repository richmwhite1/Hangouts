// Production-Ready Social Media App Schema
// Optimized for scalability, performance, and Facebook/Instagram-like features

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========================================
// ENUMS
// ========================================

enum UserRole {
  USER
  MODERATOR
  ADMIN
  SUPER_ADMIN
}

enum ContentType {
  HANGOUT
  EVENT
  COMMUNITY
}

enum ContentStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
  DELETED
}

enum PrivacyLevel {
  PRIVATE
  FRIENDS_ONLY
  PUBLIC
}

enum ConversationType {
  DIRECT
  GROUP
  COMMUNITY
}

enum ParticipantRole {
  CREATOR
  ADMIN
  MODERATOR
  MEMBER
}

enum RSVPStatus {
  PENDING
  YES
  NO
  MAYBE
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  LOCATION
  POLL
  SYSTEM
}

enum NotificationType {
  FRIEND_REQUEST
  FRIEND_ACCEPTED
  MESSAGE_RECEIVED
  CONTENT_INVITATION
  CONTENT_RSVP
  CONTENT_REMINDER
  CONTENT_UPDATE
  COMMUNITY_INVITATION
  MENTION
  LIKE
  COMMENT
  SHARE
}

enum FriendRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
  BLOCKED
}

enum ReportStatus {
  PENDING
  REVIEWED
  RESOLVED
  DISMISSED
}

// ========================================
// CORE MODELS
// ========================================

model User {
  id             String   @id @default(cuid())
  email          String   @unique
  username       String   @unique
  name           String
  avatar         String?
  backgroundImage String?
  bio            String?
  location       String?
  website        String?
  birthDate      DateTime?
  password       String
  role           UserRole @default(USER)
  isActive       Boolean  @default(true)
  isVerified     Boolean  @default(false)
  lastSeen       DateTime @default(now())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  sentFriendRequests     FriendRequest[] @relation("FriendRequestSender")
  receivedFriendRequests FriendRequest[] @relation("FriendRequestReceiver")
  friendships1           Friendship[]    @relation("User1")
  friendships2           Friendship[]    @relation("User2")
  
  // Content relations
  createdContent         Content[]
  contentParticipants    ContentParticipant[]
  
  // Messaging
  conversations          ConversationParticipant[]
  sentMessages           Message[]
  messageReads           MessageRead[]
  
  // Notifications
  notifications          Notification[]
  notificationPreferences NotificationPreference[]
  
  // Security
  refreshTokens          RefreshToken[]
  passwordResetTokens    PasswordResetToken[]
  securityLogs           SecurityLog[]
  
  // Moderation
  contentReports         ContentReport[]
  auditLogs              AuditLog[]

  @@index([email])
  @@index([username])
  @@index([isActive])
  @@index([lastSeen])
  @@index([createdAt])
  @@map("users")
}

// ========================================
// UNIFIED CONTENT SYSTEM
// ========================================

model Content {
  id            String        @id @default(cuid())
  type          ContentType
  title         String
  description   String?
  image         String?
  location      String?
  latitude      Float?
  longitude     Float?
  startTime     DateTime?
  endTime       DateTime?
  status        ContentStatus @default(DRAFT)
  privacyLevel  PrivacyLevel  @default(PRIVATE)
  creatorId     String
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Relations
  creator       User                  @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  participants  ContentParticipant[]
  messages      Message[]             @relation("ContentMessages")
  comments      Comment[]
  likes         ContentLike[]
  shares        ContentShare[]
  reports       ContentReport[]
  
  // Specific content details
  hangoutDetails HangoutDetails?
  eventDetails   EventDetails?
  communityDetails CommunityDetails?

  @@index([type])
  @@index([status])
  @@index([privacyLevel])
  @@index([startTime])
  @@index([creatorId])
  @@index([createdAt])
  @@map("content")
}

model HangoutDetails {
  id              String  @id @default(cuid())
  contentId       String  @unique
  maxParticipants Int?
  weatherEnabled  Boolean @default(false)
  tasks           Task[]
  polls           Poll[]
  itinerary       ItineraryItem[]

  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@map("hangout_details")
}

model EventDetails {
  id          String  @id @default(cuid())
  contentId   String  @unique
  venue       String?
  address     String?
  price       Decimal?
  externalUrl String?
  category    String?
  ticketUrl   String?

  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@map("event_details")
}

model CommunityDetails {
  id          String  @id @default(cuid())
  contentId   String  @unique
  memberCount Int     @default(0)
  rules       String?
  category    String?
  website     String?

  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@map("community_details")
}

model ContentParticipant {
  id          String        @id @default(cuid())
  contentId   String
  userId      String
  role        ParticipantRole @default(MEMBER)
  rsvpStatus  RSVPStatus    @default(PENDING)
  canEdit     Boolean       @default(false)
  invitedAt   DateTime      @default(now())
  respondedAt DateTime?
  joinedAt    DateTime?

  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([contentId, userId])
  @@index([contentId])
  @@index([userId])
  @@index([rsvpStatus])
  @@map("content_participants")
}

// ========================================
// MESSAGING SYSTEM
// ========================================

model Conversation {
  id              String            @id @default(cuid())
  type            ConversationType  @default(DIRECT)
  name            String?
  image           String?
  lastMessageAt   DateTime?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  participants    ConversationParticipant[]
  messages        Message[]
  messageReads    MessageRead[]

  @@index([type])
  @@index([lastMessageAt])
  @@index([createdAt])
  @@map("conversations")
}

model ConversationParticipant {
  id             String   @id @default(cuid())
  conversationId String
  userId         String
  role           ParticipantRole @default(MEMBER)
  joinedAt       DateTime @default(now())
  leftAt         DateTime?

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([conversationId])
  @@index([userId])
  @@map("conversation_participants")
}

model Message {
  id             String      @id @default(cuid())
  conversationId String?
  contentId      String?     // For content-specific messages (hangout chats)
  senderId       String
  content        String
  type           MessageType @default(TEXT)
  attachments    String[]    // Array of file URLs
  replyToId      String?
  editedAt       DateTime?
  createdAt      DateTime    @default(now())

  conversation Conversation? @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  content      Content?      @relation("ContentMessages", fields: [contentId], references: [id], onDelete: Cascade)
  sender       User          @relation(fields: [senderId], references: [id], onDelete: Cascade)
  replyTo      Message?      @relation("MessageReply", fields: [replyToId], references: [id], onDelete: SetNull)
  replies      Message[]     @relation("MessageReply")
  reads        MessageRead[]

  @@index([conversationId])
  @@index([contentId])
  @@index([senderId])
  @@index([createdAt])
  @@index([replyToId])
  @@map("messages")
}

model MessageRead {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([messageId])
  @@index([userId])
  @@map("message_reads")
}

// ========================================
// SOCIAL FEATURES
// ========================================

model FriendRequest {
  id         String             @id @default(cuid())
  senderId   String
  receiverId String
  status     FriendRequestStatus @default(PENDING)
  message    String?
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt

  sender   User @relation("FriendRequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("FriendRequestReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([senderId])
  @@index([receiverId])
  @@index([status])
  @@map("friend_requests")
}

model Friendship {
  id        String   @id @default(cuid())
  user1Id   String
  user2Id   String
  createdAt DateTime @default(now())

  user1 User @relation("User1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2 User @relation("User2", fields: [user2Id], references: [id], onDelete: Cascade)

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
  @@map("friendships")
}

model ContentLike {
  id        String   @id @default(cuid())
  contentId String
  userId    String
  createdAt DateTime @default(now())

  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([contentId, userId])
  @@index([contentId])
  @@index([userId])
  @@map("content_likes")
}

model ContentShare {
  id        String   @id @default(cuid())
  contentId String
  userId    String
  message   String?
  createdAt DateTime @default(now())

  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([contentId])
  @@index([userId])
  @@map("content_shares")
}

model Comment {
  id        String   @id @default(cuid())
  contentId String
  userId    String
  content   String
  replyToId String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  content Content  @relation(fields: [contentId], references: [id], onDelete: Cascade)
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  replyTo Comment? @relation("CommentReply", fields: [replyToId], references: [id], onDelete: SetNull)
  replies Comment[] @relation("CommentReply")

  @@index([contentId])
  @@index([userId])
  @@index([createdAt])
  @@map("comments")
}

// ========================================
// HANGOUT FEATURES
// ========================================

model Task {
  id          String     @id @default(cuid())
  hangoutId   String
  title       String
  description String?
  assignedToId String?
  status      String     @default("PENDING")
  dueDate     DateTime?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  hangoutDetails HangoutDetails @relation(fields: [hangoutId], references: [id], onDelete: Cascade)
  assignedTo    User?           @relation(fields: [assignedToId], references: [id], onDelete: SetNull)

  @@index([hangoutId])
  @@index([assignedToId])
  @@map("tasks")
}

model Poll {
  id            String   @id @default(cuid())
  hangoutId     String
  creatorId     String
  title         String
  description   String?
  options       String[]
  allowMultiple Boolean  @default(false)
  isAnonymous   Boolean  @default(false)
  expiresAt     DateTime?
  createdAt     DateTime @default(now())

  hangoutDetails HangoutDetails @relation(fields: [hangoutId], references: [id], onDelete: Cascade)
  creator        User           @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  votes          PollVote[]

  @@index([hangoutId])
  @@index([creatorId])
  @@map("polls")
}

model PollVote {
  id        String   @id @default(cuid())
  pollId    String
  userId    String
  option    String
  createdAt DateTime @default(now())

  poll Poll @relation(fields: [pollId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([pollId, userId])
  @@index([pollId])
  @@index([userId])
  @@map("poll_votes")
}

model ItineraryItem {
  id          String   @id @default(cuid())
  hangoutId   String
  title       String
  description String?
  startTime   DateTime
  endTime     DateTime
  location    String?
  order       Int
  createdAt   DateTime @default(now())

  hangoutDetails HangoutDetails @relation(fields: [hangoutId], references: [id], onDelete: Cascade)

  @@index([hangoutId])
  @@index([startTime])
  @@map("itinerary_items")
}

// ========================================
// NOTIFICATION SYSTEM
// ========================================

model Notification {
  id          String           @id @default(cuid())
  userId      String
  type        NotificationType
  title       String
  message     String
  data        Json?
  isRead      Boolean          @default(false)
  isEmailSent Boolean          @default(false)
  isPushSent  Boolean          @default(false)
  createdAt   DateTime         @default(now())
  readAt      DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([isRead])
  @@index([createdAt])
  @@map("notifications")
}

model NotificationPreference {
  id           String           @id @default(cuid())
  userId       String
  type         NotificationType
  emailEnabled Boolean          @default(true)
  pushEnabled  Boolean          @default(true)
  inAppEnabled Boolean          @default(true)
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type])
  @@index([userId])
  @@index([type])
  @@map("notification_preferences")
}

// ========================================
// MODERATION & SECURITY
// ========================================

model ContentReport {
  id          String       @id @default(cuid())
  contentId   String
  reporterId  String
  reason      String
  description String?
  status      ReportStatus @default(PENDING)
  reviewedBy  String?
  reviewedAt  DateTime?
  createdAt   DateTime     @default(now())

  content  Content @relation(fields: [contentId], references: [id], onDelete: Cascade)
  reporter User    @relation(fields: [reporterId], references: [id], onDelete: Cascade)

  @@index([contentId])
  @@index([reporterId])
  @@index([status])
  @@map("content_reports")
}

model AuditLog {
  id         String   @id @default(cuid())
  entityType String
  entityId   String
  action     String
  oldValues  Json?
  newValues  Json?
  userId     String?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([entityType])
  @@index([entityId])
  @@index([userId])
  @@index([createdAt])
  @@map("audit_logs")
}

model SecurityLog {
  id        String   @id @default(cuid())
  userId    String?
  action    String
  resource  String?
  ipAddress String?
  userAgent String?
  details   Json?
  createdAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("security_logs")
}

// ========================================
// AUTHENTICATION
// ========================================

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  tokenId   String   @unique
  expiresAt DateTime
  isRevoked Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([isRevoked])
  @@map("refresh_tokens")
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String   @unique
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([expiresAt])
  @@map("password_reset_tokens")
}
































